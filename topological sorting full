Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering
of vertices such that for every directed edge u v, vertex u comes before
v in the ordering. Topological Sorting for a graph is not possible 
if the graph is not a DAG.
For example, a topological sorting of the following graph is “5 4 2 3 1 0”. 
There can be more than one topological sorting for a graph. For example, 
another topological sorting of the following graph is “4 5 2 3 1 0”. 
The first vertex in topological sorting is always a vertex with in-degree 
as 0 (a vertex with no incoming edges).
In DFS, we print a vertex and then recursively call DFS for its adjacent vertices. 
In topological sorting, we need to print a vertex before its adjacent vertices. 
For example, in the given graph, the vertex ‘5’ should be printed before vertex ‘0’, 
but unlike DFS, the vertex ‘4’ should also be printed before vertex ‘0’. 
So Topological sorting is different from DFS. For example, a DFS of the 
shown graph is “5 2 3 1 0 4”, but it is not a topological sorting.
*/
#include <bits/stdc++.h>
using namespace std;
template <typename T>
class Graph{
    map<T,list<T>> l;
    public:
        void addEdge(T x,T y){
            l[x].push_back(y);
            //l[y].push_back(x);     directed Acyclic Graph
         }

        void dfsHelper(T src,map<T,bool> &visited,list<T> &ordering){
        // recursively traverse the graph
            //cout<<src<<" ";
            visited[src]=true;
            for(auto child:l[src]){
            // if child of src is not visited mark visited check for child
                if(!visited[child]){
                    dfsHelper(child,visited,ordering);
                }
            }
            // at this point this node is pushed to the front
            ordering.push_front(src);
            return;
        }
        void dfs(){
            map<T,bool> visited;
            // mark all the node as not visited before traversing
            for(auto x:l){
                T node=x.first;
                visited[node]=false;
            }
            list<T> ordering;
            // call dfsHelper func
            for(auto x:l){
                T node=x.first;
                if(!visited[node]) dfsHelper(node,visited,ordering); 
            }
            
            for(auto x:ordering) cout<<x<<" ";
            cout<<endl; 
        }
};
int main() {
    
    Graph<string> g;
    g.addEdge("Python","DataPreProcessing");
    g.addEdge("Python","Pytorch");
    g.addEdge("Python","ML");
    g.addEdge("Pytorch","DL");
    g.addEdge("ML","DL");
    g.addEdge("DL","FaceRecogn");
    g.addEdge("DataSet","FaceRecogn");
    g.dfs();
}


//topological sort using BFS
//using the concept of indegree
//if indegree of a node ==0 then it must come first
//traverse through all nbr of nodes and reduce it by 1 

#include<bits/stdc++.h>
using namespace std;
class Graph{
    int V;
    list<int> *adj;
    public:
        Graph(int v){
            this->V=v;
            adj=new list<int>[V];
        }
        void addEdge(int u,int v){
            //directed graph
            adj[u].push_back(v);
        }
        //BFS no recursion using Queue
        void topologicalSort(){
            //indegree no of edges pointing towards this node
            int *indegree=new int[V];
            //initially all indegree=0;
            for(int i=0;i<V;i++) indegree[i]=0;
            //update indegree by traversing edge x->y
            for(int i=0;i<V;i++){
                for(int nbr:adj[i]) indegree[nbr]++;
            }
            queue<int> q;
            for(int i=0;i<V;i++) {
                if(indegree[i]==0) q.push(i);
            }
            // start remove front in queue
            while(!q.empty()){
                int node=q.front();
                cout<<node<<endl;
                q.pop();
                //start iterate over nbr and reduce indegree by 1
                // if(any nbr indegree==0) push that nbr in queue
                for(auto nbr:adj[node]){
                    indegree[nbr]--;
                    if(indegree[nbr]==0) q.push(nbr);
                }
            }
        }
};

int main(){
    Graph g(6);
	g.addEdge(5, 2);
	g.addEdge(5, 0);
	g.addEdge(4, 0);
	g.addEdge(4, 1);
	g.addEdge(2, 3);
	g.addEdge(3, 1);
    g.topologicalSort();
    return 0;
}

