//find shortest cycle in undirected graph
// key concept is back edge and using bfs
//and to detect all the cycles bfs traversing for all node as src is to be done
// and then find the min length cycle 
/*
Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering
of vertices such that for every directed edge u v, vertex u comes before
v in the ordering. Topological Sorting for a graph is not possible 
if the graph is not a DAG.
For example, a topological sorting of the following graph is “5 4 2 3 1 0”. 
There can be more than one topological sorting for a graph. For example, 
another topological sorting of the following graph is “4 5 2 3 1 0”. 
The first vertex in topological sorting is always a vertex with in-degree 
as 0 (a vertex with no incoming edges).
In DFS, we print a vertex and then recursively call DFS for its adjacent vertices. 
In topological sorting, we need to print a vertex before its adjacent vertices. 
For example, in the given graph, the vertex ‘5’ should be printed before vertex ‘0’, 
but unlike DFS, the vertex ‘4’ should also be printed before vertex ‘0’. 
So Topological sorting is different from DFS. For example, a DFS of the 
shown graph is “5 2 3 1 0 4”, but it is not a topological sorting.
*/
#include <bits/stdc++.h>
using namespace std;
template <typename T>
class Graph{
    map<T,list<T>> l;
    public:
        void addEdge(T x,T y){
            l[x].push_back(y);
            //l[y].push_back(x);     directed Acyclic Graph
         }

        void dfsHelper(T src,map<T,bool> &visited,list<T> &ordering){
        // recursively traverse the graph
            //cout<<src<<" ";
            visited[src]=true;
            for(auto child:l[src]){
            // if child of src is not visited mark visited check for child
                if(!visited[child]){
                    dfsHelper(child,visited,ordering);
                }
            }
            // at this point this node is pushed to the front
            ordering.push_front(src);
            return;
        }
        void dfs(){
            map<T,bool> visited;
            // mark all the node as not visited before traversing
            for(auto x:l){
                T node=x.first;
                visited[node]=false;
            }
            list<T> ordering;
            // call dfsHelper func
            for(auto x:l){
                T node=x.first;
                if(!visited[node]) dfsHelper(node,visited,ordering); 
            }
            
            for(auto x:ordering) cout<<x<<" ";
            cout<<endl; 
        }
};
int main() {
    
    Graph<string> g;
    g.addEdge("Python","DataPreProcessing");
    g.addEdge("Python","Pytorch");
    g.addEdge("Python","ML");
    g.addEdge("Pytorch","DL");
    g.addEdge("ML","DL");
    g.addEdge("DL","FaceRecogn");
    g.addEdge("DataSet","FaceRecogn");
    g.dfs();
}
